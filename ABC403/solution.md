# A、B、C

没啥好说的直接模拟

# D

如果$D$是0,那么显然排序之后去重即可。

如果$D$不是0,那么$i$和$i+D$只能留一个，数字的出现次数记为点权，相当于一个独立集问题，可以用DP解决。

进一步可以发现，$i$和$i+D$这种关系是同余的，那么相当于有$D$条链，每条链作一遍独立集即可。

# E

查询前缀这种操作，令人想到Trie。

不妨将$X$和$Y$都做成Trie。

当一个字符串插入到$X$中时，去$Y$集合的字典树匹配它，如果它在该字典树中出现，则删掉其对应的字典树的整棵子树。无条件插入这个字符串到$X$的字典树中。

当一个字符串插入到$Y$中时，去$X$集合的字典树匹配它，如果能匹配到一个end节点，则舍弃这个字符串，否则加入到$Y$的字典树。

对于答案的输出即为$Y$字典树上的字符串数量，在字典树上额外维护一个子树和即可。

总复杂度是$O(\sum|S|)$

# F

因为+和*都是二目运算符，所以很自然地可以想到将一个大数拆成两个小数，分别求最短表达式最后融合。

这样就找到了最优子结构。

不过考虑到运算符的优先级，由+号合并的表达式和由*号合并的表达式应区分开，以加上合法的小括号。

更近一步，我们还有4个不由+号和*号构成的运算数，因此整个DP的状态要区分为纯运算数、加法表达式、乘法表达式三种。

转移是简单的。

总复杂度为$O(n^2)$

# G

假设当前序列我们已知奇数index的总和。

当插入一个数时，可以看作整个序列被切分为两块，对于前面的块，其答案不变。而对于后半块，奇数index的和与偶数index的和应该交换。

这样我们找到了快速更新答案的方法：分别维护奇数index和偶数index的和，适时交换。

由于维护的是动态的有序序列，因此考虑使用平衡树来维护。

在平衡树的节点上维护整棵子树的size信息以及奇偶index和信息。

合并左右子树时，左子树无条件维护；当前节点根据左子树size的奇偶性调整其更新的奇偶index和；右子树根据左子树size+1的奇偶性调整其更新的奇偶index和。

总复杂度$O(nlog_2n)$