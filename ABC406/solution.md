# A、B、C、D

没写...

# E

典中典的数位DP

$f[i][j]$表示前$i$位，目前有$j$个1的数字的数量。

$g[i][j]$表示前$i$位，目前有$j$个1的数字总和。

单独考虑$i$位填1，其这一位的额外贡献就是$2^i * f[i-1][j-1]$

套个模板就行了

# F

典中典的DFS序

从询问角度出发，我们要求的是子树和，单点修改。

子树在DFS序中是连续的一段区间，那么树状数组维护一下前缀和即可。

# G

难度陡增...

首先有典中典的DP。

设$dp[i][j]$为前$i$个商人，目前为止在$j$的最小花费。

$dp[i][j] = min\{dp[i-1][k]+C|k-j|+D|j-a_i|\}$

显然超时对吧

感觉状态上很难优化，考虑从转移上开始优化。

这个式子中存在大量的一次函数的绝对值状物，不妨考虑一下DP函数的凸性（经典slope trick）

打表之后确实是凸的，那么考虑slope trick。

设$f_i(x)=dp[i][x]$，$g_i(x)=min{f_i(y)+C|y-x|}$。

则$f_i(x)=g_{i-1}(x)+D|x-a_i|$

根据slope trick，相当于在下凸函数上加了两个一次函数，斜率分别为$-D$和$D$，分界点在$a_i$。

因为这里斜率的总变化量并不是$O(n)$的，所以常规用双优先队列+斜率差分数组的实现并不适用。

考虑维护每个点真正的斜率，下凸函数斜率的总变化为: $<a_i$的部分，斜率$-D$；$\geq a_i$的部分，斜率$+D$

那么只要我们能从$f$过渡到$g$，这个问题就变成两个区间加的数据结构问题。

现在考虑从$f$怎么求到$g$。

这个变换看起来非常扑朔迷离，实际上我们可以这样去想：对于$g$上任意一横坐标，我们可以用一条斜率为$C$或者$-C$的直线从$f$上任意一点连过去并“松弛”它。

这意味着，我们可以用斜率$-C$或者$C$去松弛$f$函数上每一点的斜率，得到$g$函数。

那么$g$就是$f$函数把斜率全部clamp到$[-C,C]$区间。

因为下凸函数的斜率是递增的，所以我们只需要在序列上lower_bound出$C$以及$-C$的位置，进行两个区间赋值即可。

在这个过程中，我们可以维护$f$最左端$(-10^5)$或者最右端($10^5$)的值，这一值在$+D|x-a_i|$处是好求的。

在松弛的过程中，我们只会修改左右两端的斜率，假设我们维护的是最左端的$f$值，那么我们找到第一个斜率不变的位置$p$，这一位置的函数值不发生变动。

在改变斜率之前，$f(p)=f(-10^5)+slopesum[-10^5,p]$，改变之后$f(p)=g(-10^5)-C*|p+10^5|$，这个改变量就求一个区间和即可。

用这种办法我们可以将$f_i->f_{i+1}$的过程变成斜率序列上两次区间赋值+两次区间加，并实时维护左端的函数值。使用线段树即可完成这一操作。

最终找到$f_n$上最小的位置即可。