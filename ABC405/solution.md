# A、B

直接模拟即可

# C

用前缀和来做加速即可

# D

从每个'E'开始广搜，然后记录一下每个元素被谁搜到的即可

# E

还算有点意思的题。

实际上直接去考虑$N=A+B+C+D$个空位中哪个位置填什么是比较费劲的，因为要求有点多。

如果我们暂时忽略Orange，那么整个序列就清晰了一些——首先前$A$个必然是Apple，那么后$C+D$个位置放置Grape或Banana是随意的。

在这个基础上我们考虑向三种水果中间“插入”若干橘子。

由于橘子的限定，需要制度第一个Grape的位置。枚举这个位置$p$，那么相当于在前$p-1$个水果形成的$p$个空位中每个位置插入若干橘子，总和为$B$。

即$\sum_{i=1}^p x[i]=B, x[i]\geq 0$的解的数量，隔板法秒了。

# F

我的做法跟官方解法不太一样。

一个直线会把圆分为两部分，所以两个直线相交等价于，第一根直线的两端点分别在第二根直线划分的两个空间内。

不妨正难则反地考虑，我们直接计算不相交的直线。

如果我们单独一条直线，可以把它想象成是环上的两个区间。那么要求的就是区间内的“子区间”数。

所以这个问题就转变为——把环展开，然后求区间内“子区间”的个数，利用扫描线即可解决。

# G

首先由基本的组合数学知识，如果一个序列有$n$个元素，每个值$i$出现了$c[i]$次，那么序列的所有去重排列的数量是$\frac{n!}{\prod_{i=1}^k c[i]!}$。

那么我们要做的就是求区间$[l,r]$内的这个值，并且保证$k=x-1$。

这里面首先涉及到“下标”维度，也涉及到“值域”维度，所以可以想到类似扫描线的做法。

但是这个分母中连乘+阶乘的形式，非常难以利用数据结构维护。

此时我们知道如果有一个“暴力”的直接维护$c[i]$的办法就可以很好地维护这个分母。

很自然想到莫队。

那么所求即为一个$c[i]$的前缀和，以及阶乘的前缀积，并且在莫队指针暴力移动的时候要支持带修。

如果使用树状数组，它的麻烦点在于修改和查询都是$log_2 n$的复杂度。

但是莫队使用$O(N\sqrt N)$次修改，$O(Q)$次查询。这里修改远大于查询。

所以我们需要一个$O(1)$修改，但是查询在$(\sqrt N)$左右复杂度的算法，即可以使用分块。

我的莫队板子稍微有点问题，最后没A过去。

发现是由于我的一个老毛病：在暴力移动$L,R$指针的时候，可能会出现$L>R$的情况，此时的贡献非常难以计算。

```c++
        while (L > l)
            add(--L);
        while (L < l)
            del(L++);
        while (R < r)
            add(++R);
        while (R > r)
            del(R--);
```
实际上应该是$L<l$的时候，先移动$R$指针到目标位置，保证在移动$L$的时候不会出现$L>R$的情况，直接改成：

```c++
        while (L > l)
            add(--L);
        while (R < r)
            add(++R);
        while (R > r)
            del(R--);
        while (L < l)
            del(L++);
```
就可以完美解决。